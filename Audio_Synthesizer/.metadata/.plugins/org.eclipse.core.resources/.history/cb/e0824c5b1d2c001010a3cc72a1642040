/******************************************************************************
* Copyright (C) 2023 Advanced Micro Devices, Inc. All Rights Reserved.
* SPDX-License-Identifier: MIT
******************************************************************************/
/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include <stdio.h>
#include <stdlib.h>

#include "platform.h"
#include "xil_printf.h"
#include "arm_math.h"
#include "arm_const_structs.h"
#include "xscutimer.h"
#include "xscugic.h"
#include "xparameters.h"
#include "xiicps.h"
#include "sleep.h"
#include "audio.h"


// Timer/Interrupt defines
#define TIMER_DEVICE_ID		XPAR_XSCUTIMER_0_DEVICE_ID
#define INTC_DEVICE_ID		XPAR_SCUGIC_SINGLE_DEVICE_ID
#define TIMER_IRPT_INTR		XPAR_SCUTIMER_INTR
#define TIMER_LOAD_VALUE	0xFFFF

#define FLOAT_TO_Q31(x)  ((q31_t)((x) * 2147483648.0f)) // Convert float to Q31

#define SAMPLE_RATE 		96000 //96kHz
#define FREQUENCY 			1000 //440Hz
#define BUFFER_SIZE (SAMPLE_RATE / FREQUENCY) 	//Berekend de sample rate over de sinus maar van 1 periode

q31_t sine_wave[BUFFER_SIZE] = {0};
float sine_wave_2[BUFFER_SIZE] = {0};

// Functies
int generate_q31_sine_wave(float * sine_wave, float frequency_f, float amplitude_f, int buffer_size);
static int Timer_Intr_Setup(XScuGic * IntcInstancePtr, XScuTimer *TimerInstancePtr, u16 TimerIntrId);

static void Timer_ISR(void * CallBackRef)
{
	XScuTimer *TimerInstancePtr = (XScuTimer *) CallBackRef;
	XScuTimer_ClearInterruptStatus(TimerInstancePtr);

	//-------------------------------------------------------//

		static int index = 0;

		float output = sine_wave_2[index];
		//q31_t output = sine_wave[index];

		Xil_Out32(I2S_DATA_TX_L_REG, output);
		Xil_Out32(I2S_DATA_TX_R_REG, output);

		index = (index + 1) % BUFFER_SIZE;

}

int main()
{
	int Status;
    init_platform();
	//Configure the IIC data structure
	IicConfig(XPAR_XIICPS_0_DEVICE_ID);

	//Configure the Audio Codec's PLL
	AudioPllConfig();

	//Configure the Line in and Line out ports.
	//Call LineInLineOutConfig() for a configuration that
	//enables the HP jack too.
	AudioConfigureJacks();
	LineinLineoutConfig();

	print("DTMF Detection Demo (8kHz Sampling)\n\r");
	print("=================================================\n\r");

	float amplitude_f = 0.5f;
	float frequency_f = 1000.0f;

	int ret = generate_q31_sine_wave(sine_wave_2, frequency_f, amplitude_f, BUFFER_SIZE);
	if(ret == -1){
		perror("Sine generation failed");
		return -1;
	}

	XScuTimer Scu_Timer;
	XScuTimer_Config *Scu_ConfigPtr;
	XScuGic IntcInstance;

	Scu_ConfigPtr = XScuTimer_LookupConfig(XPAR_PS7_SCUTIMER_0_DEVICE_ID);
	Status = XScuTimer_CfgInitialize(&Scu_Timer, Scu_ConfigPtr, Scu_ConfigPtr->BaseAddr);
	if (Status != XST_SUCCESS) {
		print("Timer Initialization Failed\r\n");
		cleanup_platform();
		return -1;
	}

	Status = Timer_Intr_Setup(&IntcInstance, &Scu_Timer, XPS_SCU_TMR_INT_ID);
	if (Status != XST_SUCCESS) {
		print("Interrupt Setup Failed\r\n");
		cleanup_platform();
		return -1;
	}

	// Configure timer to trigger at the sampling rate (8kHz)
	XScuTimer_LoadTimer(&Scu_Timer, (XPAR_PS7_CORTEXA9_0_CPU_CLK_FREQ_HZ / 2) / (unsigned int)SAMPLE_RATE);
	XScuTimer_EnableAutoReload(&Scu_Timer);
	XScuTimer_Start(&Scu_Timer);

	print("Listening for DTMF tones...\r\n");


	for (;;) {
		// Main loop - interrupt driven processing
	}

	cleanup_platform();
	return 0;
}


int generate_q31_sine_wave(q31_t * sine_wave_q, float frequency_f, float amplitude_f, int buffer_size) {
	if(frequency_f > SAMPLE_RATE){
		perror("frequency exceeds sample rate");
		return -1;
	}
	if(amplitude_f > 1.0f){
		perror("amplitude exceeds 1.0");
		return -1;
	}

	const float theta_increment = 2* PI* FREQUENCY / SAMPLE_RATE;
	static float theta = 0.0f;

	for (int i = 0; i < BUFFER_SIZE; i++) {
		theta += theta_increment ;
		if ( theta > 2* PI) theta -= 2* PI;
		float sine_value = AMPLITUDE_SINE * arm_sin_f32 (theta);

		sine_wave[i] = (float)(sine_value + AMPLITUDE_SINE);
	}
	return 0;
}

#define AMPLITUDE_SINE 300000

void generate_theta_sine_wave(float * sine_wave) {
    for (int i = 0; i < BUFFER_SIZE; i++) {
        const float theta_increment = 2* PI* FREQUENCY / SAMPLE_RATE;
		static float theta = 0.0f;
		theta += theta_increment ;
		if ( theta > 2* PI) theta -= 2* PI;
        float sine_value = AMPLITUDE_SINE * arm_sin_f32 (theta);

        // Debugging: check the sine value before casting
        //printf("sine_value: %f\r", sine_value);
		sine_wave[i] = (float)(sine_value + AMPLITUDE_SINE);
    }
}

static int Timer_Intr_Setup(XScuGic * IntcInstancePtr, XScuTimer *TimerInstancePtr, u16 TimerIntrId)
{
	int Status;
	XScuGic_Config *IntcConfig;
	IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
	Status = XScuGic_CfgInitialize(IntcInstancePtr, IntcConfig, IntcConfig->CpuBaseAddress);
	if (Status != XST_SUCCESS) return Status;

	// Step 1: Interrupt Setup
	Xil_ExceptionInit();

	// Step 2: Interrupt Setup
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_IRQ_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler, IntcInstancePtr);
	// Step 3: Interrupt Setup
	Status = XScuGic_Connect(IntcInstancePtr, TimerIntrId, (Xil_ExceptionHandler)Timer_ISR, (void *)TimerInstancePtr);
	if (Status != XST_SUCCESS) return Status;

	// Step 4: Interrupt Setup
	XScuGic_Enable(IntcInstancePtr, TimerIntrId);
	// Step 5: Interrupt Setup
	XScuTimer_EnableInterrupt(TimerInstancePtr);
	// Step 6: Interrupt Setup
	Xil_ExceptionEnable();
	return XST_SUCCESS;
}

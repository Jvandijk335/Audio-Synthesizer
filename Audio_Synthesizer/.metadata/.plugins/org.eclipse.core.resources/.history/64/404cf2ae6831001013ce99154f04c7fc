#include <stdlib.h>
#include "frequency_generator.h"

int next_wave_id = 0;

WaveNode* add_wave(WaveNode *head, int frequency, float amplitude, int sample_rate, WaveType type) {
    WaveNode *new_node = (WaveNode *)malloc(sizeof(WaveNode));
    if (!new_node) {
        perror("malloc failed");
        return head;
    }

    int buffer_size = (sample_rate / frequency) + 1 ;
    new_node->wave.buffer = (q31_t *)malloc(buffer_size * sizeof(q31_t));
    if (!new_node->wave.buffer) {
        perror("malloc failed for buffer");
        free(new_node);
        return head;
    }

    // Wave parameters
    new_node->wave.id = next_wave_id++;
    new_node->wave.frequency = frequency;
    new_node->wave.amplitude = amplitude;
    new_node->wave.buffer_size = buffer_size;
    new_node->wave.current_index = 0;
    new_node->wave.type = type;

    // Genereer de juiste golf
    int ret = 0;
    switch (type) {
        case WAVE_SINE:
            ret = generate_sine_wave_q31(new_node->wave.buffer, amplitude, frequency, sample_rate, buffer_size);
            break;
        case WAVE_TRIANGLE:
            ret = generate_triangle_wave_q31(new_node->wave.buffer, amplitude, frequency, sample_rate, buffer_size);
            break;
        case WAVE_SQUARE:
            ret = generate_square_wave_q31(new_node->wave.buffer, amplitude, frequency, sample_rate, buffer_size);
            break;
        default:
            perror("Unknown wave type");
            free(new_node->wave.buffer);
            free(new_node);
            return head;
    }

    if (ret != 0) {
        perror("wave generation failed");
        free(new_node->wave.buffer);
        free(new_node);
        return head;
    }

    new_node->next = head;
    return new_node;
}

WaveNode* remove_wave(WaveNode *head, int id) {
    WaveNode *current = head;
    WaveNode *prev = NULL;

    while (current != NULL) {
        if (current->wave.id == id) {
            if (prev == NULL) {
                // Eerste node verwijderen
                head = current->next;
            } else {
                prev->next = current->next;
            }

            if (current->wave.buffer)
                free(current->wave.buffer);
            free(current);
            return head;
        }

        prev = current;
        current = current->next;
    }

    printf("Wave with id %d not found\n", id);
    return head;
}

void free_waves(WaveNode *head) {
    WaveNode *current = head;
    while (current != NULL) {
        WaveNode *next = current->next;
        if (current->wave.buffer)
            free(current->wave.buffer);
        free(current);
        current = next;
    }
}

q31_t get_single_wave_sample_by_id(WaveNode *head, int wave_id) {
    WaveNode *current = head;

    while (current != NULL) {
        if (current->wave.id == wave_id) {
            q31_t sample = current->wave.buffer[current->wave.current_index];
            current->wave.current_index = (current->wave.current_index + 1) % current->wave.buffer_size;
            return sample;
        }
        current = current->next;
    }

    // Return silence if wave ID not found
    return 0;
}

q31_t mix_waves_sample(WaveNode *head) {
    if (head == NULL) return 0;

    int64_t sum = 0;
    int count = 0;

    WaveNode *node = head;
    while (node != NULL) {
        Wave *wave = &node->wave;

        // Haal huidige sample
        q31_t sample = wave->buffer[wave->current_index];

        // Tel op
        sum += sample;
        count++;

        // Update index met wrap-around
        wave->current_index = (wave->current_index + 1) % wave->buffer_size;
        node = node->next;
    }

    if (count == 0) return 0;

    // Gemiddelde berekenen om clipping te voorkomen
    sum /= count;

    // Saturatie naar Q31
    return (q31_t)__SSAT(sum, 31);
}

int generate_sine_wave_f(float *sine_wave_f, float amplitude_f, int frequency, int sample_rate, int buffer_size) {
    if (frequency > sample_rate/2) {
        perror("Frequency exceeds Nyquist limit");
        return -1;
    }
    if (amplitude_f > 8000000.0f) {
        perror("amplitude exceeds 1.0");
        return -1;
    }

    const float theta_increment = 2 * PI * frequency / sample_rate;
    static float theta = 0.0f;

    for (int i = 0; i < buffer_size; i++) {
        theta += theta_increment;
        if (theta > 2 * PI) theta -= 2 * PI;
        float sine_value = amplitude_f * arm_sin_f32(theta);

        sine_wave_f[i] = (float)(sine_value + REGISTER_MAX / 2);
    }
    return 0;
}

int generate_sine_wave_q31(q31_t *sine_wave_q31, float amplitude_percent, int frequency, int sample_rate, int buffer_size){
	if (frequency > sample_rate /2) {
		perror("Frequency exceeds Nyquist limit");
		return -1;
	}
	if (amplitude_percent > 100.0f || amplitude_percent < 0.0f) {
		perror("Amplitude must be between 0 and 100");
		return -1;
	}

	// Convert amplitude percentage to Q31 scaling factor
	q31_t amplitude_q31 = (q31_t)((amplitude_percent / 100.0f) * MAX_Q31);

	for (int i = 0; i < buffer_size; ++i) {
	// Create phase from 0 to just under 1.0 in Q31
	q31_t phase = (q31_t)(((uint64_t)i * 0x7FFFFFFF) / buffer_size);
	q31_t sine = arm_sin_q31(phase);
	sine = (q31_t)(((int64_t)sine * amplitude_q31) >> 31);

	// Scale from Q31 to 24-bit left-aligned DAC format
	sine_wave_q31[i] = sine >> 8;  // Q31 to Q24 (keep top 24 bits)
	}

	return 0;
}

int generate_triangle_wave_q31(q31_t *triangle_wave_q31, float amplitude_percent, int frequency, int sample_rate, int buffer_size) {
	if (frequency > sample_rate/2) {
		perror("Frequency exceeds Nyquist limit");
		return -1;
	}
	if (amplitude_percent > 100.0f || amplitude_percent < 0.0f) {
		perror("Amplitude must be between 0 and 100");
		return -1;
	}

	// Convert amplitude percentage to Q31 scaling factor
	q31_t amplitude_q31 = (q31_t)((amplitude_percent / 100.0f) * MAX_Q31);

	for (int i = 0; i < buffer_size; ++i) {
		// Generate a triangle wave phase between 0 and 1
		uint64_t phase = ((uint64_t)i * frequency * 2 * buffer_size) / sample_rate;
		phase = phase % (2 * buffer_size);  // Wrap phase to triangle shape

		q31_t value;
		if (phase < buffer_size) {
			// Rising edge
			value = (q31_t)(((int64_t)amplitude_q31 * phase) / buffer_size);
		} else {
			// Falling edge
			value = (q31_t)(((int64_t)amplitude_q31 * (2 * buffer_size - phase)) / buffer_size);
		}

		// Scale from Q31 to 24-bit DAC format
		triangle_wave_q31[i] = value >> 8; // Q31 to Q24
	}

	return 0;
}

int generate_square_wave_q31(q31_t *square_wave_q31, float amplitude_percent, int frequency, int sample_rate, int buffer_size) {
    if (frequency > sample_rate/2) {
        perror("Frequency exceeds Nyquist limit");
        return -1;
    }
    if (amplitude_percent > 100.0f || amplitude_percent < 0.0f) {
        perror("Amplitude must be between 0 and 100");
        return -1;
    }

    // Convert amplitude percentage to Q31
	q31_t amplitude_q31 = (q31_t)((amplitude_percent / 100.0f) * MAX_Q31);

	// Calculate samples per period
	int samples_per_period = sample_rate / frequency;
	int half_period = samples_per_period / 2;

	// Adaptive slew: longer for low freqs, none for high freqs
	int max_slew_samples = 8;
	int slew_samples = 0;

	if (frequency <= 1000) {
		slew_samples = max_slew_samples;
	} else if (frequency < 5000) {
		slew_samples = max_slew_samples * (5000 - frequency) / 4000;  // Linear decay
	} else {
		slew_samples = 0;
	}

	for (int i = 0; i < buffer_size; ++i) {
		int phase = i % samples_per_period;
		q31_t value;

		if (phase < half_period - slew_samples) {
			value = amplitude_q31;
		} else if (phase >= half_period + slew_samples) {
			value = -amplitude_q31;
		} else {
			// Apply linear slew
			int delta = phase - (half_period - slew_samples);
			int total = 2 * slew_samples;
			int64_t ramp = amplitude_q31 - ((int64_t)(2 * amplitude_q31) * delta / total);
			value = (q31_t)ramp;
		}

		// Convert Q31 to Q24 for DAC
		square_wave_q31[i] = value >> 8;
	}

    return 0;
}

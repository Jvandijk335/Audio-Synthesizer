#include "frequency_generator.h"

#define SLEW_SAMPLES 4  // Number of samples for edge smoothing

int generate_sine_wave_f(float *sine_wave_f, float amplitude_f, int frequency, int sample_rate, int buffer_size) {
    if (frequency > sample_rate/2) {
        perror("Frequency exceeds Nyquist limit");
        return -1;
    }
    if (amplitude_f > 8000000.0f) {
        perror("amplitude exceeds 1.0");
        return -1;
    }

    const float theta_increment = 2 * PI * frequency / sample_rate;
    static float theta = 0.0f;

    for (int i = 0; i < buffer_size; i++) {
        theta += theta_increment;
        if (theta > 2 * PI) theta -= 2 * PI;
        float sine_value = amplitude_f * arm_sin_f32(theta);

        sine_wave_f[i] = (float)(sine_value + REGISTER_MAX / 2);
    }
    return 0;
}

int generate_sine_wave_q31(q31_t *sine_wave_q31, float amplitude_percent, int frequency, int sample_rate, int buffer_size){
	if (frequency > sample_rate /2) {
		perror("Frequency exceeds Nyquist limit");
		return -1;
	}
	if (amplitude_percent > 100.0f || amplitude_percent < 0.0f) {
		perror("Amplitude must be between 0 and 100");
		return -1;
	}

	// Convert amplitude percentage to Q31 scaling factor
	q31_t amplitude_q31 = (q31_t)((amplitude_percent / 100.0f) * MAX_Q31);

	for (int i = 0; i < buffer_size; ++i) {
	// Create phase from 0 to just under 1.0 in Q31
	q31_t phase = (q31_t)(((uint64_t)i * 0x7FFFFFFF) / buffer_size);
	q31_t sine = arm_sin_q31(phase);
	sine = (q31_t)(((int64_t)sine * amplitude_q31) >> 31);

	// Scale from Q31 to 24-bit left-aligned DAC format
	sine_wave_q31[i] = sine >> 8;  // Q31 to Q24 (keep top 24 bits)
	}

	return 0;
}

int generate_triangle_wave_q31(q31_t *triangle_wave_q31, float amplitude_percent, int frequency, int sample_rate, int buffer_size) {
	if (frequency > sample_rate/2) {
		perror("Frequency exceeds Nyquist limit");
		return -1;
	}
	if (amplitude_percent > 100.0f || amplitude_percent < 0.0f) {
		perror("Amplitude must be between 0 and 100");
		return -1;
	}

	// Convert amplitude percentage to Q31 scaling factor
	q31_t amplitude_q31 = (q31_t)((amplitude_percent / 100.0f) * MAX_Q31);

	for (int i = 0; i < buffer_size; ++i) {
		// Generate a triangle wave phase between 0 and 1
		uint64_t phase = ((uint64_t)i * frequency * 2 * buffer_size) / sample_rate;
		phase = phase % (2 * buffer_size);  // Wrap phase to triangle shape

		q31_t value;
		if (phase < buffer_size) {
			// Rising edge
			value = (q31_t)(((int64_t)amplitude_q31 * phase) / buffer_size);
		} else {
			// Falling edge
			value = (q31_t)(((int64_t)amplitude_q31 * (2 * buffer_size - phase)) / buffer_size);
		}

		// Scale from Q31 to 24-bit DAC format
		triangle_wave_q31[i] = value >> 8; // Q31 to Q24
	}

	return 0;
}

int generate_square_wave_q31(q31_t *square_wave_q31, float amplitude_percent, int frequency, int sample_rate, int buffer_size) {
    if (frequency > sample_rate/2) {
        perror("Frequency exceeds Nyquist limit");
        return -1;
    }
    if (amplitude_percent > 100.0f || amplitude_percent < 0.0f) {
        perror("Amplitude must be between 0 and 100");
        return -1;
    }

    // Convert amplitude percentage to Q31 scaling factor
    q31_t amplitude_q31 = (q31_t)((amplitude_percent / 100.0f) * MAX_Q31);

    int samples_per_period = sample_rate / frequency;
    int half_period = samples_per_period / 2;
    int phase = 0;

    q31_t current_level = amplitude_q31;
    q31_t previous_level = -amplitude_q31;

    for (int i = 0; i < buffer_size;) {
		// Detect rising or falling edge
		if (phase == 0) {
			// Slew edge across SLEW_SAMPLES
			for (int j = 0; j < SLEW_SAMPLES && i < buffer_size; ++j, ++i) {
				q31_t interp = previous_level + ((int64_t)(current_level - previous_level) * j) / SLEW_SAMPLES;
				square_wave_q31[i] = interp >> 8;  // Q31 to Q24
			}
		} else {
			// Fill with constant level
			square_wave_q31[i++] = current_level >> 8;  // Q31 to Q24
		}

		phase++;
		if (phase >= half_period) {
			phase = 0;
			// Flip levels
			previous_level = current_level;
			current_level = -current_level;
		}
	}

    return 0;
}

#include "sine_generator.h"

int generate_sine_wave_f(float *sine_wave_f, float amplitude_f, int frequency, int sample_rate, int buffer_size) {
    if (frequency > sample_rate) {
        perror("frequency exceeds sample rate");
        return -1;
    }
    if (amplitude_f > 8000000.0f) {
        perror("amplitude exceeds 1.0");
        return -1;
    }



    const float theta_increment = 2 * PI * frequency / sample_rate;
    static float theta = 0.0f;

    for (int i = 0; i < buffer_size; i++) {
        theta += theta_increment;
        if (theta > 2 * PI) theta -= 2 * PI;
        float sine_value = amplitude_f * arm_sin_f32(theta);

        sine_wave_f[i] = (float)(sine_value + BIT24_MAX / 2);
    }
    return 0;
}

//int generate_sine_wave_q31(q31_t *sine_wave_q31, float amplitude){
//	if (frequency > sample_rate) {
//		perror("frequency exceeds sample rate");
//		return -1;
//	}
//	if (amplitude_f > 8000000.0f) {
//		perror("amplitude exceeds 1.0");
//		return -1;
//	}
//
//	for (int i = 0; i < BUFFER_SIZE; ++i) {
//	// Create phase from 0 to just under 1.0 in Q31
//	q31_t phase = (q31_t)(((uint64_t)i * 0xFFFFFF) / BUFFER_SIZE); //7F
//	q31_t sine = arm_sin_q31(phase);
//	sine = (q31_t)(((int64_t)sine * 0x04000000) >> 31); // 0.5x amplitude
//
//	// Scale from Q31 to 24-bit left-aligned DAC format
//	sine_wave_q31[i] = sine >> 8;  // Q31 to Q24 (keep top 24 bits)
//	}
//
//	return 0;
//}
